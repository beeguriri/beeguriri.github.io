---
layout: default
title: TCP
nav_order: 2
parent: Network
---



## 📑 TCP

- 전송계층
  - 송신자와 수신자를 연결하는 통신 서비스 제공
  - 데이터 전달
  - 전달되는 패킷의 오류를 검사하고 재전송 요구 등의 제어 담당

- 연결 지향적 프로토콜
  - 네트워크에 연결 된 컴퓨터에서 실행되는 프로그램 간 데이터를
  - 안정적으로, 순서대로, 에러 없이 교환할 수 있게 함

- 가상 회선 방식 제공
  - 3 Way Hand-shake 과정을 통해 연결 설정
  - 4 Way Hand-shake 과정을 통해 연결 해제

- 흐름 제어 : `송신측`과 `수신측`의 데이터 처리 속도 차이 해결
- 오류 제어
- 혼잡 제어 : `송신측` 데이터 전달과 `네트워크` 데이터 처리 속도 차이 해결
- 전이중 (양방향) 전송
- 점대점 전송 : 각 연결이 정확히 2개의 종단점



### ⭐ 연결 설정 / 해제

![](https://github.com/beeguriri/beeguriri.github.io/blob/main/docs/img/3way.png?raw=true)

- 3-way 연결
  - 클라이언트가 `SYN` 보내고 `SYN_SENT` 상태로 대기
  - 서버는 `SYN_RECEIVED` 상태로 변경하고 `SYN+ACK`전송
  - `SYN+ACK` 받은 클라이언트는 `Established`상태로 변경하고 `ACK` 전송
  - `ACK`받은 서버는 `Established`상태로 변경

- 4-way 연결 해제
  - 클라이언트가 `FIN` 보내고 `FIN_WAIT_1` 상태로 대기
  - 서버는 `CLOSE_WAIT` 상태로 변경하고 `ACK` 전달
  - `ACK` 받은 클라이언트는 `FIN_WAIT_2`상태로 변경
  - 서버는 종료 프로세스 진행 후 `FIN` 보내고 `LAST_ACK`로 변경
  - `FIN` 받은 클라이언트는 `ACK` 전송하고 `TIME-WAIT`로 변경 후 일정 시간이 지나면 `CLOSE`로 변경
    - `TIME_WAIT` : 먼저 연결을 끊는 쪽에서 생성되는 소켓. 혹시 모를 전송 실패 대비

  - `ACK` 받은 서버는 `CLOSE`로 변경




### ⭐ 흐름 제어

- 송신측과 수신측의 `데이터 처리 속도`가 다를 때
- 수신측에 버퍼 오버플로우 문제 발생
- `윈도우 크기`로 송신 측의 데이터 전송량 조절
- 해결 방법
  - Stop & Wait
  - Sliding window
    - 수신측이 한번에 처리할 수 있는 데이터의 양(윈도우 크기)를 통신 시 송신측에 전달
    - 패킷의 왕복시간이 길면 네트워크 혼잡하다고 판단하여 윈도우 크기를 실제 버퍼 크기보다 작게 설정
    - 통신 과정 중에도 네트워크 혼잡 등의 조건을 통해 윈도우 크기 `유동적`으로 설정



### ⭐ 오류 제어

- 전송 중 오류가 발생하면 해당 데이터 재전송
- 송신측이 보낸 데이터가 유실되거나, 수신측이 보낸 ACK 데이터가 유실 될 경우 중복된 ACK를 받음
- 해결 방법
  - Stop & Wait : 일정 시간이 지나 time-out이 발생하면 이전 데이터 재전송
  - GoBack N : (연속으로 데이터 보낼 때) 오류발생 지점부터 재전송
  - Selective Repeat : 오류가 발생한 데이터만 재전송



### ⭐ 혼잡 제어

- 네트워크의 혼잡을 피하기 위해 송신측에서 보내는 데이터의 `전송속도`를 강제로 줄임

- 네트워크 내의 패킷수가 과도하게 증가하는 것을 방지하기 위함

- 혼잡 알림 동기 문자

  - ECE  : 혼잡 알림
  - CWR : ECE 수신한 송신 프로세스가 전송 윈도우 크기 줄였음을 통지

- 해결 방법

  - AIMD
    - 처음 패킷을 하나 보내고 문제 없으면 `1개씩` 증가시켜서 보냄
    - 패킷 전송 실패 또는 일정시간 경과 시 패킷크기(윈도우 크기) `절반`으로 줄임

  - Slow start
    - 윈도우 크기를 1, 2, 4, 8, ... `2배` 증가 시켜서 보냄
    - 혼잡 감지되면 윈도우 크기 `1로` 줄임
