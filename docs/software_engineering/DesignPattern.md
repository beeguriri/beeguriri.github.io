---
layout: default
title: 디자인패턴
nav_order: 7
parent: Software Engineering
---



## 📑 디자인 패턴

- 설계 방법 제시
- 사용자의 기능 추가, 설계 변경 요청에 대한 유지보수 용이
- 문제 해결을 위한 설계자 간의 원활한 의사소통 용이
- 유사한 상황에서 개발자들의 소프트웨어 구조 파악이 용이
- 재사용을 통한 개발 시간 단축
- 초기에 시간과 노력 비용이 많이 드는 것이 단점
- 생성패턴 / 구조패턴 / 행위패턴




## 📑 생성 패턴

- 객체 인스턴스 생성을 위한 패턴
- 클래스 정의와 객체 생성 방식을 구조화, 캡슐화 하는 방법을 제시

### ⭐ 팩토리 메서드

- 객체 생성을 위한 인터페이스를 정의
- 실제 생성할 `인스턴스에 대한 결정은 서브클래스`가 함

### ⭐ 추상 팩토리

- 클래스 집합의 종류를 지정하여 관련된 객체의 `집합`을 생성할 수 있게 함

### ⭐ 싱글톤

- 클래스 인스턴스가 `하나만` 만들어 지도록 함
- 인스턴스에 대한 전역 접근 제공

### ⭐ 프로토타입

- 프로토 타입의 인스턴스를 이용하여 생성할 객체의 종류를 명세하고
- 이 프로토 타입을 `복사`해서 새로운 객체 생성

### ⭐ 빌더

- 복합 객체의 생성 과정과 표현 방법을 분리
- 부분 생성을 통한 전체 객체 생성



## 📑 구조 패턴

- 객체를 조직화 시키는 일반적인 방식 제시
- 객체를 구성하는 방식 자체에 초점
- 런타임에 객체 컴포지션 구조 변경할 수 있음

### ⭐ 어댑터 패턴

- 특정 클래스의 인터페이스를 `다른 인터페이스로 전환`
- 기존 모듈 `재사용`을 위한 인터페이스 변경

### ⭐ 파사드 패턴

- 하나의 `통합된` 인터페이스 제공

### ⭐ 브릿지 패턴

- `구현과 추상화 부분을 분리`하여 각각 독립적으로 변형할 수 있게 함

### ⭐ 컴포지트 패턴

- 부분-전체 계층을 나타내기 위해 복합 객체를 `트리구조`로 만듦

### ⭐ 데코레이터 패턴

- 객체에 `동적`으로 책임 추가
- `기능의 유연한 확장`을 위해 상속 대신 사용

### ⭐ 플라이 웨이트

- 핵심적인 부분과 부수적인 부분으로 나누어 객체를 잘게 쪼갬

### ⭐ 프록시 패턴

- `다른 객체로의 접근을 통제`하기 위해서 다른 객체의 대리자 제공



## 📑 행위 패턴

- 반복 사용되는 객체들의 상호작용을 패턴화

### ⭐ 템플릿메서드 패턴

- 상속의 개념이 있는 상위클래스에서 골격을 결정하고
- 하위 클래스에서 구체적인 내용을 결정

### ⭐ 커맨드 패턴

- 요청을 객체로 캡슐화

### ⭐ 반복자 패턴

- 동일한 방법으로 객체 집단 속의 객체가 다루어지도록 만들어진 패턴
- 동일 자료형의 여러 객체 순차 접근

### ⭐ 중재자 패턴

- 객체들 간의 상호작용을 객체로 캡슐화
- M:N 객체 관계를 M:1로 단순화

### ⭐ 메멘토 패턴

- 객체 이전 상태 복원 또는 보관

### ⭐ 옵저버 패턴

- 1:n 객체 의존관계 정의

### ⭐ 전략 패턴

- 동일 목적의 `여러 알고리즘 중 선택`해서 적용 가능하게 함

### ⭐ 비지터 패턴

- 오퍼레이션이 처리할 요소의 클래스를 변경하지 않고도 새로운 오퍼레이션 정의
