---
layout: default
title: 단일 프로세스 스케줄링
nav_order: 3
parent: os
---



## 📑 비선점

### ⭐ FCFS (First Come First Served)

- 준비큐에 도착한 순서에 따라 CPU 할당



### ⭐ SJF (Shortest Job First)

- `기다리고 있는` 작업 중에서 실행 시간이 가장 짧다고 판정된 것을 먼저 수행



### ⭐ HRN (Higtest Response-ratio Next)

- 우선순위 결정식에 따라 짧은 작업이 우선순위가 높아짐

$$
\frac{대기시간 + 서비스 받을시간}{서비스 받을 시간}
$$



## 📑 선점

### ⭐ Round Robin

- 각 프로세스는 같은 크기의 CPU 시간을 할당 받음
- Time Slice가 너무 크면 FCFS와 동일해지고,
- Time Slice가 너무 작으면 많은 문맥교환으로 CPU 유휴 시간이 증가



### ⭐ SRT (Shortest Remaining Time )

- 가장 짧은 시간이 소요된다고 판단되는 프로세스 먼저 수행



### ⭐ 다단계 큐

- 각 작업들이 서로 다른 묶음으로 분류될 수 있을 때 사용
- 준비상태 큐를 여러 단계 종류로 분할
- 어느 한 큐에 지정되면 이후 작업은 다른 큐로 이동할 수 없음



### ⭐ 다단계 피드백 큐

- CPU 사용 시간에 따라 입출력 위주와 CPU 위주로 구분하여
- 특성에 따라 서로 다른 Time-Slice 부여
- 하위단계의 큐로 옮겨 갈수록 할당시간 점차 크게 설정
- `입출력 장치`를 효과적으로 이용하기 위해 입출력 위주의 작업들에 대해 우선권 부여



## 📑 우선순위 역전 현상

- 선점형 스케줄링 방식에서 발생
- 공유 자원에 대한 lock() 때문에 발생

{: .highlight }
> 우선순위 가장 높은 A, 중간 B, 가장 낮은 C가 있을 때,
>
> C가 CPU 할당을 받고 공유 자원에 lock()을 걸면 다른 프로세스들이 이 공유 자원 사용 불가
>
> 공유 자원이 필요한 A가 작업을 수행하고자 하나 공유 자원에 lock이 걸려있어서 대기
>
> 공유 자원이 필요 없는 B가 작업을 수행하고자 하면 B가 C보다 우선순위가 높으므로 CPU 선점
>
> B 작업 완료 후 C 작업 시작, 공유 자원 unlock()
>
> A 작업 시작

- 우선순위가 가장 높은 A가 우선순위가 가장 낮은 프로세스처럼 실행이 됨



### ⭐ 해결책

- 우선순위 상속
  - 공유 자원을 사용하는 프로세스가 실행 중일 때,
  - 같은 공유 자원을 사용하려고 하는 우선순위가 더 높은 프로세스 접근 시
  - 실행 중인 프로세스의 우선순위를 우선순위 높은 프로세스의 우선순위로 임시로 바꿔줌

- 우선순위 올림
  - 공유 자원을 사용하는 프로세스가 실행 되면 그 순간부터 우선순위 올려줌
  - 다른 스레드에 의해 선점 되지 않고 자신의 작업 종료
  - 작업 종료 후 원래의 우선순위로 낮춰짐

