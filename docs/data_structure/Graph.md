---
layout: default
title: 그래프
nav_order: 8
parent: Data Structure
---



## 📑 그래프 탐색

- 무방향 그래프 : (u, v) == (v, u)
- 방향 그래프 : <u, v> != <v, u>
- 단순 그래프 : 다중 간선 허용 안함, 두 정점 사이 최대 한 개의 간선 존재
- 완전 그래프 : 최대 간선을 갖는 그래프
  - n개의 정점 가진 무방향 그래프 간선 수 n(n-1)/2
  - n개의 정점 가진 방향 그래프 간선 수 n(n-1)

### ⭐ DFS

- 인접리스트에서의 현재 위치는 `스택`에 넣어서 기억
- 아직 방문하지 않은 정점은 방문 후 스택에 넣음
- 스택이 공백이 되면 탐색 종료
- 인접리스트 O(n+e), 인접 행렬 O(n^2)

### ⭐ BFS

- 정점 v에서 시작하여 방문 표시 후, v의 인접 리스트에 있는 모든 정점들을 바로 방문
- 각 정점을 방문할 때 마다 정점은 `큐`에 저장
- 한 인접 리스트가 끝나면 큐에서 한 정점을 꺼내 그 정점의 인접리스트에 있는 정점들을 같은 방법으로 조사
- 큐가 공백이 되면 탐색 종료
- 인접리스트 O(n+e), 인접 행렬 O(n^2)



## 📑 최소 비용 신장트리

- 신장 트리 : 연결 그래프이며 동시에 사이클이 없는 그래프
- 신장 트리는 유일하지 않음
- 노드 N개에 대해 간선의 수가 N-1개

### ⭐ 크루스칼

- 한번에 한개의 `간선을 선택`하여 신장트리 선정
- 간선의 길에이 의하여 간선을 오름차순으로 정렬
- 간선의 작은 순서로 선택, 사이클을 만들면 제외
- 모든 정점이 연결 되어 신장트리가 될 때 까지 반복
- 희박한 그래프 대상으로 할 경우 적합

### ⭐ 프림

- 우선순위 우선 탐색, 가중치가 작을수록 우선순위가 높음
- 하나의 `정점`으로 된 트리 T에서 시작
- 간선의 가중치가 작은 다음 정점 선택
- 최저 비용 간선을 구해 T에 추가
- 밀집한 그래프 대상으로 할 경우 적합



## 📑 최단 경로

### ⭐ 다익스트라

- 인접 리스트 이용
- i -> i 는 0, 간선이 존재하지 않으면 `가중치를 무한대`로 함
- 시간복잡도 O(n^2)

```java
void djikstra(int start) {
    Queue<Node> pq = new LinkedList<>();
    Arrays.fill(dist, INF);
    
    pq.offer(new Node(start, 0));
    dist[start] = 0;
    
    while(!pq.isEmpty()) {
        Node node = pq.poll();
        int now = node.getIndex();
        int dist = node.getDistance()
        if(d[now]<dist)
            continue;
        for(int i=0; i<list.get(now).size(); i++) {
            int index = list.get(now).get(i).getIndex();
            int cost = d[now] + list.get(now).get(i).getDistance();
            if(cost<d[index]) {
             	d[index] = cost;
                pq.offer(new Node(index, cost));
            }
        }
    }
}
```



### ⭐ 플로이드 워셜

- 인접행렬 이용
- i==j는 0, 그 외는 INF로 채우고 간선정보 입력

```java
  for(k=1; i<=n; k++) 
    for(a=1; a<=n; a++)
      for(b=1; b<=n; b++)
        graph[a][b] = Math.min(graph[a][b], graph[a][k]+graph[k][b]);
```



## 📑 정점 작업 네트워크 (AOV)

- `정점은 작업`을 나타내고 간선이 작업 간의 선행 관계를 나타내는 방향 그래프

### ⭐ 위상 정렬

- 그래프에서 선행자가 없는 정점들을 모두 선정하여 정렬
- 이 정점들과 이들에 부속한 간선들을 그래프에서 모두 제거
- 변경 된 그래프로부터 선행자가 없는 정점들을 선정하여 정렬 과정 반복
- 모든 정점이 다 정렬 되었거나, 나머지 정점들이 모두 선행자를 가지고 있으면 종료



## 📑 간선 작업 네트워크 (AOE)

- `정점은 사건`을 나타내고, 간선은 프로젝트에서 수행되어야 할 작업을 나타냄
- 프로젝트의 스케줄을 나타낼 수 있음
- 사이클 없는 방향 그래프

### ⭐ 임계 경로

- 시작점에서 완료점 까지 시간이 가장 많이 걸리는 최장 경로
- AOE 네트워크에서는 반드시 한 개 이상의 임계 경로가 있음
- 공정 조기 완료 시간 : 시작점에서 공정 Pi까지의 최장 경로 길이
- 공정 완료 마감 시간 : 전체 프로젝트 완료시간 - (공정 Pi에서 최종 공정까지의 최장경로 길이)

![](https://github.com/beeguriri/beeguriri.github.io/blob/main/docs/img/cp.PNG?raw=true)

- 임계작업을 식별해서 이들에 자원을 집중시킴으로 프로젝트 완료시간을 단축하고자 함
- 하나의 AOE에는 여러개의 임계 경로가 있을  수 있으므로 모든 임계 경로에 공통으로 포함되는 임계 작업이 아니고서는 반드시 프로젝트 완료 시간이 단축 되는 것은 아님
